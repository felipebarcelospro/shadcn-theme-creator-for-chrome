name: 'Setup Context and Prerequisites'
description: 'Set up necessary context and prerequisites for the workflow'

inputs:
  github-token:
    description: 'GitHub token for API access'
    required: true
  debug:
    description: 'Enable debug mode'
    required: false
    default: 'true'

outputs:
  repository-context:
    description: 'JSON object containing repository context'
  config-data:
    description: 'Parsed configuration data'
  environment-variables:
    description: 'Set environment variables'
  package-manager:
    description: 'Detected package manager'
  installation-status:
    description: 'Status of the installation process'

runs:
  using: "composite"
  steps:
  - name: Cache dependencies and config
    uses: actions/cache@v3
    id: cache
    with:
      path: |
        ~/.npm
        ~/.yarn
        ~/.pnpm-store
        .github/config.yml
      key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json', '**/yarn.lock', '**/pnpm-lock.yaml', '.github/config.yml') }}

  - name: Install action dependencies
    if: steps.cache.outputs.cache-hit != 'true'
    shell: bash
    run: npm install --no-save fs js-yaml

  - name: Setup Context and Prerequisites
    uses: actions/github-script@v6
    with:
      github-token: ${{ inputs.github-token }}
      script: |
        const fs = require('fs');
        const yaml = require('js-yaml');
        const { execSync } = require('child_process');

        const DEBUG = '${{ inputs.debug }}' === 'true';

        function debug(message) {
          if (DEBUG) console.log(`DEBUG: ${message}`);
        }

        try {
          // Load and parse config.yml
          const configPath = '.github/config.yml';
          if (!fs.existsSync(configPath)) throw new Error('config.yml is missing');
          const configData = yaml.load(fs.readFileSync(configPath, 'utf8'));
          core.setOutput('config-data', JSON.stringify(configData));
          debug('Config data loaded and parsed');

          // Detect package manager
          const packageManager = (() => {
            const configuredManager = configData.packages?.global_settings?.ci_cd?.package_manager;
            if (configuredManager) return configuredManager;
            if (fs.existsSync('package-lock.json')) return 'npm';
            if (fs.existsSync('yarn.lock')) return 'yarn';
            if (fs.existsSync('pnpm-lock.yaml')) return 'pnpm';
            throw new Error('No supported package manager lock file found');
          })();
          core.setOutput('package-manager', packageManager);
          debug(`Package manager detected: ${packageManager}`);

          // Install dependencies if cache miss
          if ('${{ steps.cache.outputs.cache-hit }}' !== 'true') {
            const installCommands = {
              npm: 'npm ci',
              yarn: 'yarn install --frozen-lockfile',
              pnpm: 'pnpm install --frozen-lockfile'
            };
            if (!installCommands[packageManager]) throw new Error(`Unsupported package manager: ${packageManager}`);
            execSync(installCommands[packageManager], { stdio: 'inherit' });
            core.setOutput('installation-status', 'success');
            debug('Dependencies installed successfully');
          } else {
            core.setOutput('installation-status', 'cached');
            debug('Using cached dependencies');
          }

          // Fetch repository metadata (consider caching this as well)
          const cacheKey = `repo-metadata-${context.repo.owner}-${context.repo.repo}`;
          let repoMetadata = core.getState(cacheKey);
          if (!repoMetadata) {
            repoMetadata = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            core.saveState(cacheKey, JSON.stringify(repoMetadata));
            debug('Repository metadata fetched and cached');
          } else {
            repoMetadata = JSON.parse(repoMetadata);
            debug('Using cached repository metadata');
          }

          // Set up environment variables
          const envVars = {
            REPO_NAME: `${context.repo.owner}/${context.repo.repo}`,
            REPO_OWNER: context.repo.owner,
            GITHUB_SHA: context.sha,
            GITHUB_REF: context.ref,
            PACKAGE_MANAGER: packageManager,
            REPO_TYPE: configData.repository.type,
            MAIN_BRANCHES: JSON.stringify(configData.repository.version_control.main_branches),
            BRANCH_PREFIXES: JSON.stringify(configData.repository.version_control.branch_prefixes),
            MERGE_STRATEGY: JSON.stringify(configData.repository.version_control.merge_strategy),
            PROTECTED_BRANCHES: JSON.stringify(configData.repository.version_control.protected_branches)
          };
          Object.entries(envVars).forEach(([key, value]) => {
            core.exportVariable(key, value);
            debug(`Environment variable set: ${key}`);
          });
          core.setOutput('environment-variables', 'Environment variables set');

          // Validate repository settings
          if (!repoMetadata.data.has_issues && configData.issue_management.auto_label.enabled) {
            core.warning('Issues are not enabled for this repository, but issue management is configured');
          }
          if (!repoMetadata.data.has_projects && configData.repository.type === 'monorepo') {
            core.warning('Projects are not enabled for this repository, but it is configured as a monorepo');
          }

          // Set repository context
          const repositoryContext = {
            repoMetadata: repoMetadata.data,
            config: configData,
            branch: context.ref.replace('refs/heads/', ''),
            commit: context.sha,
            repoType: configData.repository.type,
            mainBranches: configData.repository.version_control.main_branches,
            branchPrefixes: configData.repository.version_control.branch_prefixes,
            mergeStrategy: configData.repository.version_control.merge_strategy,
            protectedBranches: configData.repository.version_control.protected_branches,
            packageManager
          };
          core.setOutput('repository-context', JSON.stringify(repositoryContext));
          debug('Repository context set');

          console.log('Setup context and prerequisites completed successfully');
        } catch (error) {
          core.setFailed(`Action failed: ${error.message}`);
          if (DEBUG) console.error(error);
        }

  - name: Cleanup
    if: always()
    shell: bash
    run: |
      rm -rf node_modules
      npm cache clean --force
